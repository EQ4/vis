
Hand-Crafted Particle Visualization to Music, via SDL, OpenGL and libsquirrel

== There's a demo! You want a demo? Sure you want a demo! ==

I've recorded a play-through of the demo script file, and you can find links to
the resulting movies here:

http://kaedenn.net/vis/sample.ogv
  This is the highest quality recording, in Theora format. It's huge; over 20MB
  in size.

http://kaedenn.net/vis/sample.mov
  This is the second-highest quality recording. There are a lot of visual
  artifacts (boxes, blur, etc). It's only 1.2MB though.

http://kaedenn.net/vis/sample.wmv
  This is the lowest quality recording. It looks awful, but you're able to tell
  what's going on, at least. It's also 1.2MB. You should download this ONLY IF
  you are unable to play QuickTime MOV files. If you're on a Mac, download the
  MOV. If you're on Windows, try the MOV first, then try this one if the MOV
  fails to run.

== A little bit of background information ==

This project is a glorified script-able particle engine intended for providing
a complex visualization for songs. Because "trans-coding" audio to a MIDI
format is practically impossible, all of the scheduling--that is, writing the
script to emit the particles--must be done by hand. This is where a keen ear
and substantial knowledge of music theory comes in, neither of which I claim to
have.

This leads to an interesting dichotomy: one one hand, simpler songs would be
easier to schedule, but they would lead to a fairly boring visualization. On
the other hand, however, complex songs require a lot of work to figure out
what's going on. I hope I've hit an acceptable compromise in the song I've
chosen: the Bowser theme from Super Mario World 2: Yoshi's Island. Being a
theme from an old video game, the theme is not overly complex. It also has a
repeat point, meaning I can drag on the visualization for as long as I please.
In this specific project, I schedule two minutes and 43.69 seconds.

== Compiling this thing ==

This project depends on kcc (https://github.com/Kaedenn/kcc), SDL and OpenGL.
To compile without kcc, change the line defining $(CC) in the Makefile to use
gcc with your favorite command-line arguments. For example,

CC = gcc -Wall -Wextra -ansi -pedantic --std=c99

would /mostly/ do the trick. You need to change a few other things, too, such
as replacing the -O option with -O2 or -O3, the -x option with --std, and
removing the -bb options.

== Running this thing ==

This project has two methods of operation: interactively or by parsing a
script. Despite their similarity, they both work in completely different ways.
Commands issued interactively cause particles to emit immediately, while a
script schedules the particles to be emitted after a specific delay, in
hundredths of a second. The two methods share most of the same commands, with
the most important command being "emit", taking twenty-two (yes, twenty-two)
arguments:

emit <N> <X> <Y> <uX> <uY> <R> <uR> <dS> <udS> <T> <uT> <L> <uL>
     <CR> <CG> <CB> <uCR> <uCG> <uCB> <FO> <LI> <BL>

<N>:         number of particles to emit
<X>, <Y>:    where to emit the particles, in pixels (0-800, 0-600)
<uX>, <uY>:  "uncertainty" in position: particles will appear between
             <X> - <uX> and <X> + <uX>, and <Y> - <uY> and <Y> + <uY>
<R>,  <uR>:  radius of the particles, plus-or-minus <uR>
<dS>, <udS>: linear velocity of the particles, plus-or-minus <udS>
<T>,  <uT>:  angle of trajectory, plus-or-minus <uT>
<L>,  <uL>:  lifetime of the particles in 100ths of a second
<CR>, <uCR>: "redness" of the particles
<CG>, <uCG>: "greenness" of the particles
<CB>, <uCB>: "blueness" of the particles
<FO>:        ID of the force method to apply (see below)
<LI>:        ID of the limiting method to apply (see below)
<BL>:        ID of the alpha blending function to use (see below)

The force methods are:
0 - no force
1 - friction: particles slow down gradually
2 - gravity: particles accelerate downward over time

The limit methods are:
0 - no limit: particles are free to leave the display area
1 - box: particles stop once they hit the borders of the display area
2 - springbox: particles bounce off the borders of the display area

The alpha blending functions are:
0 - no blend: particles suddenly vanish when they die
1 - linear blend: particles fade away linearly
2 - quadratic blend: particles fade according to a parabola
3 - neggamma blend: particles fade according to a bell-curve

The other commands: "kick", "strum", "snare" and "rain" are unimportant; they
only exist for testing and are modeled by an emit. See frame.c to see exactly
how that's done. Realistically, these four commands would never appear in a
real script file.

Both the interactive and script methods understand the "bgc" command as well:

bgc <R> <G> <B> <A>: change the background color

Now, the program understands the following commands only when running
interactively:

load <scriptfile>: loads <scriptfile> and begins emitting immediately
exit: quit the program

== Running a script ==

This program was always intended to be invoked with a script as an argument. I
use the scripting language known as "squirrel" (http://www.squirrel-lang.org).
See "script.nut" in the project root directory for an example of this language.
To run the program with that script file, you would use the following command:

$ ./vis -l script.nut

The -l option loads and executes the argument.

== Making a script ==

The visualization program exports several functions and constants:

variable __flist_instance__:
  This is a pointer to the internal frame list. The script is responsible for
  keeping track of it. Yes, I know this is potentially a problem, but I don't
  see a strong reason to believe this could be used as a security threat. At
  least, not yet.

function emit(flist, when, <other arguments>):
  flist: must be __flist_instance__
  when: the time to emit, in 100ths of a second
  <other arguments>: exactly as they were for the above "emit" command

function audio(flist, filename):
  flist: must be __flist_instance__
  filename: a string containing the path to a .wav file to play

function bgcolor(flist, red, green, blue):
  flist: mist be __flist_instance__
  red, green, blue: values between 0 and 1 for the new background color

function mutate(flist, mutate_type, mutate_arg):
  flist: must be __flist_instance__
  mutate_type: performs an action affecting all particles on screen,
    immediately. see below for the mutation constants
  mutate_arg: depends on the mutate type as to what this does

constants:
  FPS_LIMIT: maximum frames-per-second of the visualization
  WIDTH: width of the window in pixels
  HEIGHT: height of the window in pixels
  
  == force constants ==
  DEFAULT_FORCE: force value 0
  FRICTION: force value 1
  GRAVITY: force value 2
  NFORCES: not a force, but has the value 3
  
  == limit constants ==
  DEFAULT_LIMIT: limit value 0
  BOX: limit value 1
  SPRINGBOX: limit value 2
  NLIMITS: not a limiter, but has the value 3
  
  == mutate constants ==
  MUTATE_PUSH: mutate value 0: multiplies particles' velocity by the argument
    given
  MUTATE_SLOW: mutate value 1: multiplies particles' velocity by the argument
    given
  MUTATE_SHRINK: mutate value 2: divides particles' radii by the argument given
  MUTATE_GROW: mutate value 3: multiply particles' radii by the argument given
  NMUTATES: not a mutation, but has the value 4

== Known bugs and flaws ==

Seeking a track does not keep the particle emission times synchronized
properly; the track and the particles are no longer synchronized.

The program fails to keep up to the FPS limit, leading to the particles to lag
behind the track.

There is a mysterious segmentation fault after having the program run for a
length of time. It is not known how to reproduce this segmentation fault.

== Future improvements and in-progress work ==

Reworking the engine to use a bucket structure: prevent the program from having
to traverse a linked-list each frame by storing just a linked-list of
"buckets", or an array of sequential particles. These buckets would have a
fixed size (say 1,000 or 10,000). This would greatly speed up the program
because dereferencing a pointer is far more expensive than traversing a
sequence of memory, due to paging, caching and other lovely magic.

Reworking the engine to use an arena allocator: prevent the program from
allocating each and every particle separately by allocating a large array of
particles all at once. This is necessary for the bucket structure to work and
would lead to much fewer total allocations and freeings. According to the
profiling, this may or may not make a difference for the execution speed of the
program, but would allow for other more effective optimizations.

== Credit where credit is due ==

Thank you SNESmusic.org for the Bowser theme, retrieved at
http://snesmusic.org/v2/profile.php?profile=set&selected=2757
on the 8th of October 2011.
